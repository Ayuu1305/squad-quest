rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Check if the user is not touching restricted fields
    function notUpdating(fields) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(fields);
    }
    
    function isQuestHost(questId) {
      return get(/databases/$(database)/documents/quests/$(questId)).data.hostId == request.auth.uid;
    }

    // üõ°Ô∏è NEW: Validate incoming data types (Basic Schema Validation)
    function isValidQuest() {
       let data = request.resource.data;
       return data.title is string && data.title.size() < 100 
           && data.description is string 
           && data.maxMembers is number;
    }

    // ‚úÖ USERS
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId);

      allow update: if isOwner(userId)
        && notUpdating([
          'xp', 'level', 'thisWeekXP', 'reliabilityScore', 
          'badges', 'daily_streak', 'last_claimed_at',
          'roles', 'isAdmin' // üõ°Ô∏è ADDED: Prevent users from making themselves Admin
        ]);

      allow delete: if false;

      match /joinedQuests/{questId} {
        allow read, create, delete: if isOwner(userId);
        allow update: if false;
      }
    }

    // ‚úÖ USER STATS (Backup/Private storage)
    match /userStats/{userId} {
      allow read: if isOwner(userId); // üõ°Ô∏è CHANGED: Only the owner should see their private stats
      allow write: if false;
    }

    // ‚úÖ BOUNTIES (The Economy)
    // üõ°Ô∏è ADDED: Frontend needs to READ bounties, but only Backend writes them.
    match /bounties/{bountyId} {
      allow read: if isAuthenticated();
      allow write: if false; 
    }

    // ‚úÖ QUESTS
    match /quests/{questId} {
      allow read: if isAuthenticated();
      
      // üõ°Ô∏è UPDATED: Added schema validation
      allow create: if isAuthenticated() && isValidQuest() && request.resource.data.hostId == request.auth.uid;

      allow update: if isAuthenticated() && (
        // Host can update details
        (resource.data.hostId == request.auth.uid && 
         notUpdating(['members', 'membersCount', 'completedBy', 'createdAt', 'hostId'])) ||
        
        // Quest members can mark completed (Strict check)
        (exists(/databases/$(database)/documents/quests/$(questId)/members/$(request.auth.uid)) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(["status", "completedBy", "updatedAt"]) &&
         request.resource.data.status in ['active', 'completed']) || // üõ°Ô∏è ADDED: Validate status
        
        // Join/Leave Logic
        // üõ°Ô∏è NOTE: This is still tricky. Ideally, manage Join/Leave via Cloud Functions or Batch Writes
        // for perfect security. This rule allows array updates but blocks other fields.
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(["members", "membersCount", "updatedAt"])
      );

      allow delete: if resource.data.hostId == request.auth.uid;

      // ‚úÖ MEMBERS SUBCOLLECTION
      match /members/{memberId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && request.auth.uid == memberId;
        allow delete: if isAuthenticated() && request.auth.uid == memberId;
        allow update: if false;
      }

      // ‚úÖ CHAT
      match /chat/{messageId} {
        allow read: if isAuthenticated()
          && exists(/databases/$(database)/documents/quests/$(questId)/members/$(request.auth.uid));

        allow create: if isAuthenticated()
          && exists(/databases/$(database)/documents/quests/$(questId)/members/$(request.auth.uid))
          && request.resource.data.senderId == request.auth.uid; // üõ°Ô∏è ADDED: Sender must be YOU

        allow delete: if isQuestHost(questId);
      }

      // ‚úÖ VERIFICATIONS
      match /verifications/{userId} {
        allow read: if isAuthenticated()
          && exists(/databases/$(database)/documents/quests/$(questId)/members/$(request.auth.uid));

        allow create: if isAuthenticated()
          && request.auth.uid == userId
          && exists(/databases/$(database)/documents/quests/$(questId)/members/$(request.auth.uid));
        
        allow delete: if isQuestHost(questId);
      }
    }

    // ‚úÖ HUBS
    match /hubs/{hubId} {
      allow read: if true;
      allow write: if false;
    }

    // ‚úÖ GLOBAL ACTIVITY FEED
    match /global_activity/{docId} {
      allow read: if isAuthenticated();
      // üõ°Ô∏è UPDATED: Users can only log THEIR OWN activity
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // ‚úÖ HALL OF FAME
    match /hall_of_fame/{docId} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // ‚úÖ REPORTS
    match /reports/{docId} {
      allow create: if isAuthenticated() && request.resource.data.reporterId == request.auth.uid;
      allow read, update, delete: if false;
    }
    
    // Default deny for everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}