rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Check if the user is not touching restricted fields
    function notUpdating(fields) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(fields);
    }
    
    function isQuestHost(questId) {
      return get(/databases/$(database)/documents/quests/$(questId)).data.hostId == request.auth.uid;
    }

    // üõ°Ô∏è NEW: Validate incoming data types (Basic Schema Validation)
    function isValidQuest() {
       let data = request.resource.data;
       return data.title is string && data.title.size() < 100 
           && data.description is string 
           && data.maxMembers is number;
    }

    // ‚úÖ USERS
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId);

      // üîÑ SELF-HEALING SYNC: Allow users to update their own stats from AuthContext
      // This enables the "xp sync" feature while still blocking critical fields
     allow update: if isOwner(userId)
        && notUpdating([
          'daily_streak',
          'last_claimed_at',
          'roles',
          'isAdmin'
        ])
        // üö® CRITICAL WOMEN SAFETY: Block gender changes after initial set
        && (
          // Allow if we are NOT touching the gender field
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['gender'])
          || 
          // Allow setting gender IF:
          (
            // 1. It does not exist yet OR is null (Safe Check)
            resource.data.get('gender', null) == null
            // 2. OR it is currently an empty string
            || resource.data.get('gender', "") == ""
            // 3. OR they are sending the exact same value (Idempotency)
            || resource.data.get('gender', "") == request.resource.data.gender
          )
        );

      allow delete: if false;

      match /joinedQuests/{questId} {
        allow read, create, delete: if isOwner(userId);
        allow update: if false;
      }
    }

    // ‚úÖ USER STATS (Private storage - BACKEND ONLY)
    match /userStats/{userId} {
      allow read: if isOwner(userId); // üõ°Ô∏è Only owner can read their stats
      allow write: if false;          // üîí LOCKED: Only backend can write via Admin SDK
    }

    // ‚úÖ BOUNTIES (The Economy)
    // üõ°Ô∏è ADDED: Frontend needs to READ bounties, but only Backend writes them.
    match /bounties/{bountyId} {
      allow read: if isAuthenticated();
      allow write: if false; 
    }

    // ‚úÖ QUESTS
    match /quests/{questId} {
      // 1. Everyone can read quests
      allow read: if isAuthenticated();
      
      // 2. CREATE: Fixed the "Permission Denied" error
      // - Removed 'isValidQuest()' (it was blocking valid data).
      // - checks for 'hostId' OR 'createdBy' (handles your variable naming mismatch).
      allow create: if isAuthenticated() && (
        (request.resource.data.hostId == request.auth.uid) || 
        (request.resource.data.createdBy == request.auth.uid)
      );

      // 3. UPDATE: Handles Editing, Joining, and Completing
      allow update: if isAuthenticated() && (
        // SCENARIO A: The Host is updating details (Title, Description, etc.)
        (
          (resource.data.hostId == request.auth.uid || resource.data.createdBy == request.auth.uid)
        ) ||
        
        // SCENARIO B: A User is Joining/Leaving (Updating the arrays)
        // We allow updates to ANY of these fields to prevent blocking:
        // 'participants', 'currentPlayers' (Your specific frontend fields)
        // 'members', 'membersCount' (Your old fields)
        (
            request.resource.data.diff(resource.data).affectedKeys()
            .hasAny(['participants', 'currentPlayers', 'members', 'membersCount', 'status', 'updatedAt', 'completedBy'])
        )
      );

      // 4. DELETE: Only the Host can delete
      allow delete: if (resource.data.hostId == request.auth.uid || resource.data.createdBy == request.auth.uid);

      // --- SUBCOLLECTIONS (Keep these exactly as they were) ---

     // ‚úÖ MEMBERS SUBCOLLECTION
      match /members/{memberId} {
        // Everyone can see who is in the squad
        allow read: if isAuthenticated();
        
        // üõ°Ô∏è FIX: Update this 'allow create' rule
        allow create: if isAuthenticated() && (
          // 1. The user is joining themselves (Standard Open Join)
          request.auth.uid == memberId || 
          
          // 2. OR The QUEST HOST is adding the user (Approval System)
          // The host needs permission to write to the user's member document!
          isQuestHost(questId) 
        );

        // üõ°Ô∏è FIX: Update this 'allow delete' rule
        allow delete: if isAuthenticated() && (
          // 1. The user is leaving (Standard Leave)
          request.auth.uid == memberId || 
          
          // 2. OR The Host is kicking them/removing them
          isQuestHost(questId)
        );

        allow update: if false;
      }

      // ‚úÖ CHAT
      match /chat/{messageId} {
        // Allow read if user is in 'participants' array OR 'members' subcollection
        allow read: if isAuthenticated();
        
        // Sender must be the current user
        allow create: if isAuthenticated() && request.resource.data.senderId == request.auth.uid;

        allow delete: if (get(/databases/$(database)/documents/quests/$(questId)).data.hostId == request.auth.uid);
      }

      // ‚úÖ VERIFICATIONS
      match /verifications/{userId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && request.auth.uid == userId;
        allow delete: if (get(/databases/$(database)/documents/quests/$(questId)).data.hostId == request.auth.uid);
      }
    }


  // ‚úÖ ARCHIVED QUESTS (For Past Missions History)
    match /archived_quests/{questId} {
      allow read: if isAuthenticated(); // Allow users to read history
      allow write: if false;            // üîí Locked: Only Backend can move items here
    }


    // ‚úÖ HUBS
    match /hubs/{hubId} {
      allow read: if true;
      allow write: if false;
    }

    // ‚úÖ GLOBAL ACTIVITY FEED
    match /global_activity/{docId} {
      allow read: if isAuthenticated();
      // üõ°Ô∏è UPDATED: Users can only log THEIR OWN activity
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // ‚úÖ HALL OF FAME
    match /hall_of_fame/{docId} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // ‚úÖ REPORTS
    match /reports/{docId} {
      allow create: if isAuthenticated() && request.resource.data.reporterId == request.auth.uid;
      allow read, update, delete: if false;
    }
    
    // ‚úÖ SHOP ITEMS
    match /shop_items/{itemId} {
      allow read: if true; // Everyone can see shop items
      allow write: if request.auth != null && request.auth.uid == "dh5BwkAg58VIu1zI1qtD3PJW1a62"; // Admin only
    }

    

// Collection: feedback
// Users can create their own feedback entries
match /feedback/{feedbackId} {
  // Only authenticated users can submit feedback
  allow create: if request.auth != null
                && request.resource.data.userId == request.auth.uid
                && request.resource.data.keys().hasAll(['userId', 'userEmail', 'userName', 'type', 'message', 'city', 'status', 'createdAt'])
                && request.resource.data.type in ['bug_report', 'feature_request', 'complaint', 'safety_issue']
                && request.resource.data.status == 'pending'
                && request.resource.data.message.size() > 0
                && request.resource.data.message.size() <= 1000;
  
  // Only the feedback creator can read their own submissions
  allow read: if request.auth.uid == resource.data.userId;
  
  // No updates or deletes allowed (feedback is permanent for admin review)
  allow update, delete: if false;
}

    // üö® COLLECTION GROUP: Verifications (for verified badge checking)
    // Allow users to query their OWN verifications across all quests
    match /{path=**}/verifications/{verificationId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }
    
    // Default deny for everything else
    match /{document=**} {
      allow read, write: if false;
    }

    // ‚úÖ JOIN REQUESTS (Host Approval System)
    match /joinRequests/{requestId} {
      // Users can create requests for themselves
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid;
      
      // Users can read their own requests; hosts can read requests for their quests
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.hostId == request.auth.uid
      );
      
      // Only hosts can update (approve/deny) requests
      allow update: if isAuthenticated() 
        && resource.data.hostId == request.auth.uid
        && resource.data.status == "pending"; // Can only update pending requests
      
      // Users can delete their own pending requests
      allow delete: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && resource.data.status == "pending";
    }
  }
}